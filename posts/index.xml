<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on fukasawah&#39;s blog</title>
		<link>https://fukasawah.github.io/posts/</link>
		<description>Recent content in Posts on fukasawah&#39;s blog</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>ja-JP</language>
		<lastBuildDate>Mon, 25 Mar 2019 02:16:16 +0900</lastBuildDate>
		<atom:link href="https://fukasawah.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>VPS ServerのセットアップとLetsEncryptによる証明書取得と利用まで(Google Cloud DNS Service)</title>
			<link>https://fukasawah.github.io/posts/vps-server-setup/</link>
			<pubDate>Mon, 25 Mar 2019 02:16:16 +0900</pubDate>
			
			<guid>https://fukasawah.github.io/posts/vps-server-setup/</guid>
			<description>まずは入っているパッケージを適当に最新化 yum update reboot ユーザを作る # ユーザ作成 useradd fukasawah # パスワード設定 passwd fukasawah # wheelを与えてsudoを使えるようにする</description>
			<content type="html"><![CDATA[

<p>まずは入っているパッケージを適当に最新化</p>

<pre><code>yum update
reboot
</code></pre>

<p>ユーザを作る</p>

<pre><code># ユーザ作成
useradd fukasawah
# パスワード設定
passwd fukasawah

# wheelを与えてsudoを使えるようにする
usermod -G wheel fukasawah
id fukasawah

# 作成したユーザに変更
su - fukasawah

# sudoが使えるか確認。パスワード設定した時のパスワードが必要
sudo ls -l /
</code></pre>

<h3 id="ssh鍵の生成">SSH鍵の生成</h3>

<p>作成したユーザに対して行う。既に公開鍵の準備がある場合は、後述のauthorized_keysに追記する手順まで飛ばす。</p>

<pre><code>$ ssh-keygen -t rsa -b 4096
Generating public/private rsa key pair.
Enter file in which to save the key (/home/fukasawah/.ssh/id_rsa):
Created directory '/home/fukasawah/.ssh'.
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /home/fukasawah/.ssh/id_rsa.
Your public key has been saved in /home/fukasawah/.ssh/id_rsa.pub.
The key fingerprint is:
1c:03:30:bb:05:59:23:de:96:02:5a:5b:b2:48:c9:e9 fukasawah@ik1-309-14734.vs.sakura.ne.jp
The key's randomart image is:
+--[ RSA 4096]----+
|..* *++          |
|.B B.* +         |
|+ o + = o        |
| E   = . o       |
|    .   S        |
|                 |
|                 |
|                 |
|                 |
+-----------------+
</code></pre>

<p>信頼できる公開鍵として登録しておく</p>

<pre><code>cat .ssh/id_rsa.pub &gt;&gt; .ssh/authorized_keys
chmod 0600 .ssh/authorized_keys
</code></pre>

<p>秘密鍵はSSH接続時に必要になるので内容をコピーして手元に持ってきておく</p>

<pre><code>cat .ssh/id_rsa
</code></pre>

<p>表示された <code>-----BEGIN RSA PRIVATE KEY-----</code>から<code>-----END RSA PRIVATE KEY-----</code>までの間の内容が秘密鍵なので、これをSSH接続したい端末にコピーする。</p>

<p>以降は必要ないので削除しておく</p>

<h3 id="sshサーバのセキュリティを高める">SSHサーバのセキュリティを高める</h3>

<p>rootユーザで行う。</p>

<p>SSHサーバに以下の設定を施す。</p>

<ul>
<li>パスワード認証を無効（公開鍵認証）</li>
<li>rootのログイン無効（作成したユーザからsuでログインする）</li>
<li>空のパスワードログインを無効（必ずパスワード設定しないとログインできないようにする）</li>
</ul>

<pre><code>cp /etc/ssh/sshd_config /etc/ssh/sshd_config.bak
vi /etc/ssh/sshd_config
</code></pre>

<p>diffでバックアップとの差分を出して以下のように変更されたことを確認</p>

<pre><code>#diff /etc/ssh/sshd_config.bak /etc/ssh/sshd_config
55c55
&lt; #PubkeyAuthentication yes
---
&gt; PubkeyAuthentication yes
78,79c78,79
&lt; #PermitEmptyPasswords no
&lt; PasswordAuthentication yes
---
&gt; PermitEmptyPasswords no
&gt; PasswordAuthentication no
</code></pre>

<pre><code>問題がなければsshdを再起動
systemctl restart sshd
</code></pre>

<p>以下を確認する</p>

<ul>
<li>root＋パスワード認証でログインできないこと</li>
<li>作成したユーザ＋パスワード認証でログインできないこと</li>
<li>作成したユーザ＋公開鍵認証でログインできること</li>
</ul>

<h3 id="ロケールとタイムゾーンの変更">ロケールとタイムゾーンの変更</h3>

<p>OS設定のロケールとタイムゾーンを日本に合わせる</p>

<pre><code># ロケールの確認
locale
# タイムゾーンの確認
date
</code></pre>

<p>以下のコマンドで変更する。</p>

<pre><code># ロケール変更
sudo localectl set-locale LANG=ja_JP.UTF-8

# タイムゾーン変更
sudo timedatectl set-timezone Asia/Tokyo
</code></pre>

<p>ロケールは再接続後に反映される。</p>

<pre><code># ロケールの確認
locale
# タイムゾーンの変更の確認
date
</code></pre>

<h2 id="let-s-encryptでssl証明書を作る">Let&rsquo;s EncryptでSSL証明書を作る</h2>

<p>ドメインは Google Domainsで管理しており、ワイルドカード証明書を発行したい。</p>

<p>ワイルドカード証明書の場合、DNS-01認証が必須でありDNSサーバに対してTXTレコードを書き込む必要がある。
一般的なドメインレジストリ（お名前.com、Value-Domain等）でも手動で行えば可能ではあるが、90日の有効期間しかないため、この作業は自動化したい。</p>

<p>もちろん、スクレイピングなどを駆使すれば出来なくはないがデザイン変更などでスクレイピングプログラムが動かなくなるリスクも考えられる。そのあたりを考えると大変。
そこで、DNSをAPIで操作できるサービスを利用する。こちらならAPIが変わらない限り動かなくなることもなく、失敗時の動作もわかりやすい。</p>

<p>ただ、そのためには、ドメインレジストリで管理しているネームサーバではなく、サービス提供のネームサーバに転送し、解決させるようにする必要がある</p>

<p>今回はCoocle Cloud Platformで提供されているGoogle Cloud DNS Serviceを使う。ちなみに、Azure DNSでも同じ要領で出来る。
LetsEncryptによる証明書の作成・更新を行うためのプログラムには、certbot+certbot-dns-google プラグインを使う。</p>

<ul>
<li>Google Cloud DNS Serviceへゾーンを作成する</li>
<li>ネームサーバを変更(Google domains -&gt; Google Cloud DNS Service)</li>
<li>Google Cloud DNS Serviceの認可情報を作る</li>
</ul>

<h3 id="google-cloud-dns-serviceへゾーンを作成する">Google Cloud DNS Serviceへゾーンを作成する</h3>

<p><a href="https://cloud.google.com/dns/">https://cloud.google.com/dns/</a></p>

<p>ゾーンはドメインに対してDNSレコードを管理する単位で、1ドメインにつき1ゾーンを作ることになる。</p>

<p>以下を進めて、Google Cloud DNS Serviceを有効化にする。</p>

<p><a href="https://console.cloud.google.com/net-services/dns/zones">https://console.cloud.google.com/net-services/dns/zones</a></p>

<p>ゾーンを作成する。</p>

<ul>
<li>ゾーンタイプ: 公開</li>
<li>ゾーン名: 自由</li>
<li>DNS名: 取得したドメイン名</li>
<li>DNSSEC: オン</li>
</ul>

<p><img src="/images/vps-server-setup/2019-03-16-21-14-23.png" alt="" /></p>

<p>作成出来たらゾーンについてネームサーバが割り当たる。ゾーンで登録したレコードの情報はこのネームサーバに設定される。</p>

<h3 id="ネームサーバを変更-google-domains-google-cloud-dns-service">ネームサーバを変更(Google domains -&gt; Google Cloud DNS Service)</h3>

<p>Google Cloud DNS Serviceでゾーンを作成した時に得られたネームサーバをGoogle Domainsに登録する。</p>

<p>まず、<a href="https://domains.google.com/">Google Domains</a>を開き、ネームサーバを変更する。</p>

<p><img src="/images/vps-server-setup/2019-03-16-21-20-14.png" alt="" /></p>

<p>この変更は最長1日ぐらいかかる。結構時間がかかった。</p>

<h3 id="google-cloud-dns-serviceの認可情報を作る">Google Cloud DNS Serviceの認可情報を作る</h3>

<p>次にGoogle DNSでDNS登録をプログラムが行えるようにOAuth2認証の準備をする</p>

<p><a href="https://developers.google.com/identity/protocols/OAuth2ServiceAccount#creatinganaccount">https://developers.google.com/identity/protocols/OAuth2ServiceAccount#creatinganaccount</a></p>

<ul>
<li>プロジェクトを作る(fukasawah-devとした)</li>
<li>サービスアカウントを作る（certbotとした）</li>
<li>サービスアカウントの権限を設定する（DNS管理者とした。おそらくこれが必要最小限の権限）</li>
<li>キーの作成を行い、JSONファイルで出力する。これがクレデンシャル情報となる。</li>
</ul>

<p>ここで生成したJSONファイルはこの後使う。</p>

<p>クレデンシャル情報は自分の代わりに操作を許すための認証情報という扱いなので、絶対に人に見せてはいけない。
また、もし漏れた場合でも影響を抑えるため、権限は必要最小限に設定する。</p>

<h3 id="certbotでssl証明書を発行する">certbotでSSL証明書を発行する</h3>

<p><a href="https://docs.docker.com/install/linux/docker-ce/centos/">https://docs.docker.com/install/linux/docker-ce/centos/</a></p>

<p>今回はdockerとcertbotを使う。dockerのほうが環境が汚れなくて精神衛生上よいため。</p>

<pre><code>yum install -y yum-utils device-mapper-persistent-data lvm2
yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo
yum install docker-ce docker-ce-cli containerd.io

systemctl start docker
systemctl enable docker
</code></pre>

<p>dockerのインストールが終わったら作業ディレクトリを用意する</p>

<pre><code>groupadd letsencrypt
mkdir -p /etc/letsencrypt /var/lib/letsencrypt /var/log/letsencrypt
chmod 0770 /etc/letsencrypt /var/lib/letsencrypt /var/log/letsencrypt
chown root:letsencrypt /etc/letsencrypt /var/lib/letsencrypt /var/log/letsencrypt
</code></pre>

<p>実行前にGoogle Cloud DNSを操作するための認証情報をJSONファイルで与える必要があるので、先ほどダウンロードしたJSONファイルを送る。</p>

<pre><code>vi /etc/letsencrypt/google.json
chmod 0600 /etc/letsencrypt/google.json
</code></pre>

<p>ドメインはよしなに置き換える</p>

<pre><code>sudo docker run -it --rm --name certbot \
            -v &quot;/etc/letsencrypt:/etc/letsencrypt&quot; \
            -v &quot;/var/lib/letsencrypt:/var/lib/letsencrypt&quot; \
            -v &quot;/var/log/letsencrypt:/var/log/letsencrypt&quot; \
            certbot/dns-google certonly \
  --dns-google \
  --dns-google-credentials /etc/letsencrypt/google.json \
  --dns-google-propagation-seconds 120 \
  -d fukasawah.dev \
  -d *.fukasawah.dev
</code></pre>

<p>実行すると3つほど尋ねられる。</p>

<ul>
<li>再発行やセキュリティの通知先のEmail</li>
<li>利用規約とその同意</li>
<li>非営利組織Electronic Frontier Foundationの活動を伝えるため、メールアドレスを共有してよいか？（Noでよい）</li>
</ul>

<pre><code>Enter email address (used for urgent renewal and security notices) (Enter 'c' to
cancel): メールアドレスを入力

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Please read the Terms of Service at
https://letsencrypt.org/documents/LE-SA-v1.2-November-15-2017.pdf. You must
agree in order to register with the ACME server at
https://acme-v02.api.letsencrypt.org/directory
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
(A)gree/(C)ancel: A

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Would you be willing to share your email address with the Electronic Frontier
Foundation, a founding partner of the Let's Encrypt project and the non-profit
organization that develops Certbot? We'd like to send you email about our work
encrypting the web, EFF news, campaigns, and ways to support digital freedom.
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
(Y)es/(N)o: N

</code></pre>

<p>実行後、Cloud DNS上をみると、以下のようにレコードを登録していることが分かる。
<img src="/images/vps-server-setup/2019-03-17-22-59-38.png" alt="" /></p>

<p>うまくいくと以下のような形になる。</p>

<pre><code>IMPORTANT NOTES:
 - Congratulations! Your certificate and chain have been saved at:
   /etc/letsencrypt/live/fukasawah.dev/fullchain.pem
   Your key file has been saved at:
   /etc/letsencrypt/live/fukasawah.dev/privkey.pem
   Your cert will expire on 2019-06-15. To obtain a new or tweaked
   version of this certificate in the future, simply run certbot
   again. To non-interactively renew *all* of your certificates, run
   &quot;certbot renew&quot;
 - If you like Certbot, please consider supporting our work by:

   Donating to ISRG / Let's Encrypt:   https://letsencrypt.org/donate
   Donating to EFF:                    https://eff.org/donate-le

</code></pre>

<p>以下の場所に生成される。<code>fukasawah.dev</code>はドメイン名なので実行する環境で変わる。</p>

<ul>
<li>証明書（CAのみ）: <code>/etc/letsencrypt/live/fukasawah.dev/chain.pem</code></li>
<li>証明書（ドメインのみ）: <code>/etc/letsencrypt/live/fukasawah.dev/cert.pem</code></li>
<li>証明書（CA+ドメイン）: <code>/etc/letsencrypt/live/fukasawah.dev/fullchain.pem</code></li>
<li>秘密鍵: <code>/etc/letsencrypt/live/fukasawah.dev/privkey.pem</code></li>
</ul>

<p>fullchainとprivkeyを良く使うことになるはず。</p>

<p>opensslコマンドで証明書の内容を覗くことができる。</p>

<pre><code>openssl x509 -text /etc/letsencrypt/live/fukasawah.dev/fullchain.pem
</code></pre>

<p>なお、ファイルパスはシンボリックリンクされており、再発行(renew)してもファイルパスが変わらないように配慮されている。</p>

<p>ちなみに<code>certbot</code>実行時、TXTレコードが反映されるまでデフォルト60秒待つのだけど、それが間に合わなかったのか以下のように失敗することがあった。
なので、<code>--dns-google-propagation-seconds 120</code>オプションを足している。</p>

<pre><code>IMPORTANT NOTES:
 - The following errors were reported by the server:

   Domain: fukasawah.dev
   Type:   unauthorized
   Detail: No TXT record found at _acme-challenge.fukasawah.dev

   To fix these errors, please make sure that your domain name was
   entered correctly and the DNS A/AAAA record(s) for that domain
   contain(s) the right IP address.
 - Your account credentials have been saved in your Certbot
   configuration directory at /etc/letsencrypt. You should make a
   secure backup of this folder now. This configuration directory will
   also contain certificates and private keys obtained by Certbot so
   making regular backups of this folder is ideal.

</code></pre>

<h3 id="再発行を試す">再発行を試す</h3>

<p>期限が近付いてきたときにちゃんと証明書が更新されるか確認する。</p>

<p>通常はLetsEncryptのAPIのリミットにかからないように、手元の証明書が本当に更新が必要かどうか検証してから行うようになっている。
ただ、それだと再試行まで時間がかかってしまうので、<code>--force-renew</code>オプションで無理やり再発行する。</p>

<pre><code>sudo docker run -it --rm --name certbot \
            -v &quot;/etc/letsencrypt:/etc/letsencrypt&quot; \
            -v &quot;/var/lib/letsencrypt:/var/lib/letsencrypt&quot; \
            -v &quot;/var/log/letsencrypt:/var/log/letsencrypt&quot; \
            certbot/dns-google renew --force-renew
</code></pre>

<p>うまくいけば、<code>ls -l /etc/letsencrypt/archive/*</code>で証明書と秘密鍵が増えているはず。</p>

<h3 id="cronで自動実行する">cronで自動実行する</h3>

<p>自動化するまでがお仕事です。今回はCronを使う。</p>

<p>cronでrootユーザでrenewを定期的に実行する</p>

<pre><code>sudo crontab -e
</code></pre>

<p>毎日午前3時12分に実行する。（時間はずらす）</p>

<pre><code>12 3 * * * docker run -it --rm --name certbot -v &quot;/etc/letsencrypt:/etc/letsencrypt&quot; -v &quot;/var/lib/letsencrypt:/var/lib/letsencrypt&quot; -v &quot;/var/log/letsencrypt:/var/log/letsencrypt&quot; certbot/dns-google renew
</code></pre>

<h2 id="nginxの導入とssl証明書の利用">nginxの導入とSSL証明書の利用</h2>

<p>nginxの導入は手抜き</p>

<pre><code>sudo yum install nginx
</code></pre>

<p><code>sudo vi /etc/nginx/nginx.conf</code></p>

<p>HTTP(tcp/80)は使わないので、この部分を上書きしていく。「</p>

<pre><code>    server {
        listen       80 default_server;
        listen       [::]:80 default_server;

        ...
    }
</code></pre>

<p>以下のように置き換える。</p>

<pre><code>    server {
        listen 443 ssl http2;
        listen [::]:443 ssl http2;

        # certs sent to the client in SERVER HELLO are concatenated in ssl_certificate
        ssl_certificate /etc/letsencrypt/live/fukasawah.dev/fullchain.pem;
        ssl_certificate_key /etc/letsencrypt/live/fukasawah.dev/privkey.pem;
        ssl_session_timeout 1d;
        ssl_session_cache shared:SSL:50m;
        ssl_session_tickets off;
        # modern configuration. tweak to your needs.
        ssl_protocols TLSv1.2;
        ssl_ciphers 'ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256';
        ssl_prefer_server_ciphers on;

        # HSTS (ngx_http_headers_module is required) (15768000 seconds = 6 months)
        add_header Strict-Transport-Security max-age=15768000;

        # OCSP Stapling ---
        # fetch OCSP records from URL in ssl_certificate and cache them
        ssl_stapling on;
        ssl_stapling_verify on;

        ## verify chain of trust of OCSP response using Root CA and Intermediate certs
        ssl_trusted_certificate /etc/letsencrypt/live/fukasawah.dev/chain.pem;

        server_name  _;
        root         /usr/share/nginx/html;

        # Load configuration files for the default server block.
        include /etc/nginx/default.d/*.conf;

        location / {
        }

        error_page 404 /404.html;
            location = /40x.html {
        }

        error_page 500 502 503 504 /50x.html;
            location = /50x.html {
        }
    }
</code></pre>

<p>なお、この元ネタは以下から生成している。
<a href="https://mozilla.github.io/server-side-tls/ssl-config-generator/">https://mozilla.github.io/server-side-tls/ssl-config-generator/</a></p>

<p>以下の行が違うだけで、<code>fukasawah.dev</code>を自ドメインに置き換えればよい。</p>

<ul>
<li><code>ssl_certificate</code></li>
<li><code>ssl_certificate_key</code></li>
<li><code>ssl_trusted_certificate</code></li>
</ul>

<p>設定が終わったら、サーバの起動・自動起動</p>

<pre><code>systemctl start nginx
systemctl enable nginx

systemctl status nginx
</code></pre>

<p>https(tcp/443)のポートはファイアウォールで塞がれているので、firewalldの設定を変更し、https(tcp/443)からのアクセスを許可する</p>

<pre><code>firewall-cmd --add-service=https --zone=public 
firewall-cmd --add-service=https --zone=public --permanent
</code></pre>

<p>Chrome等のブラウザでアクセスして表示されればOK</p>

<p><img src="/images/vps-server-setup/2019-03-17-23-35-31.png" alt="" /></p>

<p>SSLの妥当性もテストしてくれるサービスがあるので、これも試す。
<a href="https://www.ssllabs.com/ssltest/">https://www.ssllabs.com/ssltest/</a></p>

<p><img src="/images/vps-server-setup/2019-03-17-23-40-44.png" alt="" /></p>

<p>いいですね。</p>
]]></content>
		</item>
		
		<item>
			<title>GNU ldで一部をスタティックリンクにする</title>
			<link>https://fukasawah.github.io/posts/a-part-static-link-in-gnu-ld/</link>
			<pubDate>Mon, 07 Jan 2019 03:15:17 +0900</pubDate>
			
			<guid>https://fukasawah.github.io/posts/a-part-static-link-in-gnu-ld/</guid>
			<description>tl;dr gccなら-Wl,...でリンク時のオプション(==ldコマンドのオプション)を渡せる。オプションが複数ある場合はカンマで繋げる。 ldのオ</description>
			<content type="html"><![CDATA[

<h2 id="tl-dr">tl;dr</h2>

<p><code>gcc</code>なら<code>-Wl,...</code>でリンク時のオプション(==<code>ld</code>コマンドのオプション)を渡せる。オプションが複数ある場合はカンマで繋げる。</p>

<p><code>ld</code>のオプションで動的(<code>-Bdynamic</code>)と静的(<code>-Bstatic</code>)を選ぶことができ、これは混在させることができる。</p>

<p>例: glibc以外をstatic linkしたい</p>

<pre><code>g++ -o a.out main.o -static-libgcc -static-libstdc++ -Wl,-Bdynamic,-lc,-ldl,-lpthread,-Bstatic,-lboost_program_options,-lboost_filesystem,-lboost_system,-lssl,-lcrypto,-lz
</code></pre>

<p><code>-lc,-ldl,-lpthread</code>あたりがglibcのライブラリ。</p>

<h2 id="背景">背景</h2>

<p>時代はコンテナや！シングルバイナリのほうが扱い楽やで！！「実行する環境によっては～」なんて考える必要なくなるで！！</p>

<p>という雑な認識で、static linkしていくぞという感じです。詳細は伏せますが、C++でBoost等を扱ってるネットワークアプリケーションです。</p>

<p>最初は軽くググって<code>-static</code>とか<code>-static-libgcc -static-libstdc++</code>辺りをつけておけばそうなるんでしょ？と思っていて、以下のようにやっていた。</p>

<pre><code># g++ -o a.out main.o -lboost_program_options -lboost_filesystem -lboost_system -lpthread -lssl -lcrypto -lz -ldl -static -static-libstdc

...中略
warning: Using 'getaddrinfo' in statically linked applications requires at runtime the shared libraries from the glibc version used for linking
warning: Using 'gethostbyname' in statically linked applications requires at runtime the shared libraries from the glibc version used for linking
...中略

# ldd a.out
        not a dynamic executable
</code></pre>

<p>警告が出ながらも実行ファイルが出来てしまう。私は愚かなので「これでうまく動くぞ！」と思った。
しかし、いざコンテナにコピーして実行してみると、通信時に名前解決が出来ずハマった。具体的には、docker-composeで実行した時にコンテナの名前解決ができなかった。
名前解決できていないようなので「/etc/resolve.confかなぁ？」とか「でも中に入ってcurlは実行できたから違いそうだし・・・」とか1日中悩んでた。警告嫁。</p>

<p>原因はglibcのNSS回りだった。</p>

<h3 id="glibcのnssの壁">glibcのNSSの壁</h3>

<p>glibcをstatic linkすると、Name Service Switch(NSS)の都合で名前解決に支障が出るバイナリになる。</p>

<p>調べてみると、<a href="https://sourceware.org/glibc/wiki/FAQ#Even_statically_linked_programs_need_some_shared_libraries_which_is_not_acceptable_for_me.__What_can_I_do.3F">glibcはNSSの都合上、static linkは推奨していないようだ。</a>
（glibcはNSSはリンク時ではなく実行時に解決できるほうが良いとしている。ただ、これでstatic linkは事実上出来ないようなものなので、static linkしようとしたら警告じゃなくてエラーにしてほしい・・・）</p>

<p>NSSをstatic linkで扱う機能はオプショナルで、Fedoraのyumで入れられるglibcパッケージは対応していない。</p>

<p>なので、取れる手は以下の3つらしい。</p>

<ol>
<li>glibcを動的リンクして使う（従来通り）</li>
<li>glibcを<code>--enable-static-nss</code>をつけてrebuildし、必要なサービスを静的リンクする</li>
<li>glibcを辞めてlibc互換ライブラリに置き換える（musl等）</li>
</ol>

<p>今回は(1)の方法を取った。</p>

<p>でも、それだけなら<code>-ldl -static -static-libstdc</code>を外して動的リンクすればよい。</p>

<p>これでは何も新しい事をしていない。なので、glibc以外をstatic linkにしようと考えた。</p>

<p>本来の目的のシングルバイナリ化をするなら(2)と(3)なので、そのうち試したい所&hellip;</p>

<h3 id="リンカーとは">リンカーとは</h3>

<p>ふわっと理解しているつもりで説明すると、C言語、C++ではコンパイル→リンクという流れで成果物（実行ファイル・ライブラリ等）が出来上がる。</p>

<p>例えば「ライブラリの関数を呼ぼうとしたときに、その関数がどこにあるのか？」というのを、コンパイル後に行っている「リンク」のタイミングで解決している。
具体例で言えば、printfはおまじない的に<code>#include &lt;stdio.h&gt;</code>と書いていると使えるが、じゃあ実際にprintfに該当する処理はどこにあるんだ？というのを「リンク」のタイミングで解決する。</p>

<p>「リンク」の作業を行うのが「リンカー」でリンクのやり方は大きく分けてDynamic LinkとStatic Linkがある。</p>

<p>Dynamic Linkなら、ライブラリが実在すればそれでよしとして、成果物に含まれている「実行時に読み込むライブラリ一覧」みたいなものにライブラリ名を記録しておき、実行時に読みに行くような形を取る。成果物には実行時に読むという処理は含まれておらず、<code>ld.so</code>等の「プログラム実行時にライブラリを探すプログラム（動的リンカー）」の力を借りる必要がある。（ちなみにどの動的リンカーを使うかは成果物に含まれている情報から読み取る）</p>

<p>Static Linkなら、ライブラリが持つ実際の処理(関数等)を探して成果物に含める。</p>

<p>実際はもっと複雑な事をやってると思いますが、多分あってるんじゃないかな・・・</p>

<h3 id="リンカーのオプション">リンカーのオプション</h3>

<p><code>gcc</code>はコンパイルのあと、必要であればリンクも（<code>ld</code>コマンドを呼び出して）行う。
この時に<code>ld</code>コマンドのオプションを<code>-Wl,[OPTION],[OPTION],...</code>という感じに渡せる。オプションが複数ある場合はカンマ(<code>,</code>)で繋げる。</p>

<p><code>ld</code>のオプションで動的(<code>-Bdynamic</code>)と静的(<code>-Bstatic</code>)を選ぶことができ、混在させることができる。</p>

<p><code>ld</code>の実行内容が気になる場合、<code>-v,--verbose</code>辺りをつけると少し見えます。どうやってライブラリを探しているのか等が気になる場合につける。</p>

<p>例: glibc以外をstatic linkしたい</p>

<pre><code>g++ -o a.out main.o -static-libgcc -static-libstdc++ -Wl,-Bdynamic,-lc,-ldl,-lpthread,-Bstatic,-lboost_program_options,-lboost_filesystem,-lboost_system,-lssl,-lcrypto,-lz
</code></pre>

<p><code>-lc,-ldl,-lpthread</code>辺りはglibcに含まれるライブラリでべったり依存しているので、ここら辺は動的リンクにします。</p>

<h3 id="成果">成果</h3>

<p>通常時</p>

<pre><code># g++ -o a.out main.o -Wl,-lpthread,-lboost_program_options,-lboost_filesystem,-lboost_system,-lssl,-lcrypto,-lz
# ldd a.out | sort
        /lib64/ld-linux-x86-64.so.2 (0x00007f9f7d619000)
        libboost_filesystem.so.1.66.0 =&gt; /lib64/libboost_filesystem.so.1.66.0 (0x00007f9f7d54d000)
        libboost_program_options.so.1.66.0 =&gt; /lib64/libboost_program_options.so.1.66.0 (0x00007f9f7d56a000)
        libboost_system.so.1.66.0 =&gt; /lib64/libboost_system.so.1.66.0 (0x00007f9f7d546000)
        libcrypto.so.1.1 =&gt; /lib64/libcrypto.so.1.1 (0x00007f9f7d1d6000)
        libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f9f7ccbd000)
        libdl.so.2 =&gt; /lib64/libdl.so.2 (0x00007f9f7ccab000)
        libgcc_s.so.1 =&gt; /lib64/libgcc_s.so.1 (0x00007f9f7ce83000)
        libm.so.6 =&gt; /lib64/libm.so.6 (0x00007f9f7ce9e000)
        libpthread.so.0 =&gt; /lib64/libpthread.so.0 (0x00007f9f7d5ed000)
        librt.so.1 =&gt; /lib64/librt.so.1 (0x00007f9f7ccb3000)
        libssl.so.1.1 =&gt; /lib64/libssl.so.1.1 (0x00007f9f7d4b0000)
        libstdc++.so.6 =&gt; /lib64/libstdc++.so.6 (0x00007f9f7d022000)
        libz.so.1 =&gt; /lib64/libz.so.1 (0x00007f9f7d1ba000)
        linux-vdso.so.1 (0x00007ffdf87b5000)
</code></pre>

<p>一部を静的リンク</p>

<pre><code># g++ -o a.out main.o -static-libgcc -static-libstdc++ -Wl,-Bdynamic,-lc,-ldl,-lpthread,-Bstatic,-lboost_program_options,-lboost_filesystem,-lboost_system,-lssl,-lcrypto,-lz
# ldd a.out | sort
        /lib64/ld-linux-x86-64.so.2 (0x00007fa5d1ed4000)
        libc.so.6 =&gt; /lib64/libc.so.6 (0x00007fa5d1d04000)
        libdl.so.2 =&gt; /lib64/libdl.so.2 (0x00007fa5d1cfe000)
        libm.so.6 =&gt; /lib64/libm.so.6 (0x00007fa5d1b58000)
        libpthread.so.0 =&gt; /lib64/libpthread.so.0 (0x00007fa5d1cdc000)
        linux-vdso.so.1 (0x00007ffcf53cd000)
</code></pre>

<p>boost等が消えて、4つのライブラリにしか依存していないように見える。良いですね。</p>

<h3 id="おまけ-nssを考慮する">（おまけ）NSSを考慮する</h3>

<p>が、glibcのNSSの都合で、一部はリンク時ではなく実行時に解決される。実行時のものはlddでも表示されない。</p>

<p>ソースコードを<a href="https://sourceware.org/git/?p=glibc.git;a=blob;f=nss/nsswitch.c;h=ee46f24424bc1ca2085f4fd7f1060ae330ee5bae;hb=437faa9675dd916ac7b239d4584b932a11fbb984#l363"><code>nss/nsswitch.c</code>のこの辺り</a>で<code>/etc/nsswitch.conf</code>に書かれたサービス名(dns等)を使って、ライブラリ名を構築して、ライブラリを読みに行こうとしているのがわかる。</p>

<p>なので、もし、<code>/etc/nsswitch.conf</code>の内容が以下の場合、</p>

<pre><code>hosts: files dns
</code></pre>

<p>さらに以下を加える必要がある。</p>

<ul>
<li>/lib64/libnss_files-2.28.so</li>
<li>/lib64/libnss_dns-2.28.so</li>
<li>/lib64/libresolv-2.28.so (dnsの依存)</li>
</ul>

<p>もちろん、libresolvといった依存ライブラリがあるモノは一緒に含めないといけない。
あと、ファイルパスは実行環境やglibcのバージョンなどで変わるはずなので、<code>ldd /lib64/libnss_dns-2.28.so</code>等で、いい感じに見極めてください。</p>

<p>依存ライブラリも洗い出せたのでコンテナに持ち込むぞー！となったが、これもまた苦労した。</p>

<h3 id="おまけ-コンテナを作る">（おまけ）コンテナを作る</h3>

<p>単純にライブラリをコピーしてお終いというわけにはいかなかった。</p>

<p>持ち込み先のコンテナに動的リンカーがない。そんな事があるのか？と思ったらコンテナ界隈では良く知られているらしい。</p>

<p>busyboxはそもそも<code>ld.so</code>が無い。(これは動的リンクが必要なプログラムは実行できない・・・ということ？)</p>

<p>alpineはmuslベースなので<code>ld-musl-x86_64.so.1</code>で<code>ld-linux-x86-64.so.2</code>が無い。</p>

<p>alpineで<code>apk add libc6-compat</code> すればよい、という記事をいくつか見かけて試したが、
これはただ<code>ld-musl-x86_64.so.1</code>へのシンボリックリンクを作るだけであり、私の環境では実行時に以下のようなエラーになってしまう。</p>

<pre><code>/ # /path/to/a.out
Error relocating /path/to/a.out: __fprintf_chk: symbol not found
Error relocating /path/to/a.out: makecontext: symbol not found
Error relocating /path/to/a.out: setcontext: symbol not found
Error relocating /path/to/a.out: __register_atfork: symbol not found
Error relocating /path/to/a.out: __memcpy_chk: symbol not found
Error relocating /path/to/a.out: __strcat_chk: symbol not found
Error relocating /path/to/a.out: secure_getenv: symbol not found
Error relocating /path/to/a.out: __vfprintf_chk: symbol not found
Error relocating /path/to/a.out: __memset_chk: symbol not found
Error relocating /path/to/a.out: getcontext: symbol not found
Error relocating /path/to/a.out: __sprintf_chk: symbol not found
</code></pre>

<p><code>__memset_chk</code>辺りはglibc固有の実装なので、そんなものは当然muslにはない。</p>

<p><a href="https://hub.docker.com/r/frolvlad/alpine-glibc/">alpine-glibc</a>というイメージを使う手もあるが、オフィシャルではないので使用は避けたい。</p>

<p>色々悩んだけど、そもそもビルド環境からコピーすれば良いよね、という考えに至った。</p>

<p>ということで、dockerfileはこんな感じ。</p>

<pre><code class="language-dockerfile">FROM mydev:latest as build

# ... プログラムのビルドを行う

FROM busybox
# nsswitch.confを作る(glibcがこれを読みに来る)
RUN echo 'hosts: files dns' &gt;&gt; /etc/nsswitch.conf

# ld-linux-x86-64.so.2とプログラムの依存ライブラリ
COPY --from=build /lib64/ld-linux-x86-64.so.2 /lib64/libc.so.6 /lib64/libdl.so.2 /lib64/libm.so.6 /lib64/libpthread.so.0 /lib64

# glibcが/etc/nsswitch.confを参照して利用する依存ライブラリ
COPY --from=build /lib64/libresolv-2.28.so /lib64/lib/libresolv.so.2
COPY --from=build /lib64/libnss_dns-2.28.so /lib64/libnss_dns.so.2
COPY --from=build /lib64/libnss_files-2.28.so /lib64/libnss_files.so.2

# プログラム
COPY --from=build /usr/local/src/a.out /usr/local/bin/a.out

CMD [&quot;/usr/local/bin/a.out&quot;]
</code></pre>

<p>蛇足だが、プログラム内部で<code>ld.so</code>の場所を持っているので、コマンドを実行するとちゃんと<code>ld.so</code>を使って動的リンクを行ってくれる。(lddで<code>/lib64/ld-linux-x86-64.so.2</code>と出るなら、これを動的リンカーに使おうとする。この場所に動的リンカーが無い場合はエラーになる)
また、今回のように目的の場所に無い場合は、直接<code>ld.so</code>からプログラムを実行することもできます。もし<code>/lib64</code>ではなく、<code>/usr/local/lib</code>に全部配置した場合はこんな感じ。</p>

<pre><code>CMD [&quot;/usr/local/lib/ld-linux-x86-64.so.2&quot;, &quot;--inhibit-cache&quot;, &quot;--library-path&quot;, &quot;/usr/local/lib&quot;, &quot;/usr/local/bin/a.out&quot;]
</code></pre>

<h3 id="一部とか中途半端">一部とか中途半端</h3>

<p>はい・・・</p>

<p><code>--enable-static-nss</code>を入れたglibcでstatic linkしたりmuslの置き換えもやってみたい・・・特にmuslはlibstdc++のリビルドが必要そうなのでしんどそう。</p>

<p>glibcはLGPLなので、Static Linkすると都合悪い場合もあるはずなので、使えるのではないかなと思う。</p>

<h2 id="static化で遭遇したエラーたち">static化で遭遇したエラーたち</h2>

<h3 id="cannot-find-lgcc-s"><code>cannot find -lgcc_s</code></h3>

<pre><code>/usr/bin/ld: cannot find -lgcc_s
/usr/bin/ld: cannot find -lgcc_s
</code></pre>

<p>g++オプションに<code>-static-libgcc</code>をつける。</p>

<h3 id="undefined-reference-to-symbol-tls-get-addr-glibc-2-3"><code>undefined reference to symbol '__tls_get_addr@@GLIBC_2.3'</code></h3>

<pre><code>/usr/bin/ld: /usr/lib/gcc/x86_64-redhat-linux/8/libstdc++.a(eh_globals.o): undefined reference to symbol '__tls_get_addr@@GLIBC_2.3'
/usr/bin/ld: //lib64/ld-linux-x86-64.so.2: error adding symbols: DSO missing from command line
collect2: error: ld returned 1 exit status
</code></pre>

<p>g++オプションに<code>-static-libstdc++</code>をつける。</p>

<h3 id="undefined-reference-to-dlopen"><code>undefined reference to 'dlopen'</code></h3>

<pre><code>/usr/bin/ld: /usr/lib/gcc/x86_64-redhat-linux/8/../../../../lib64/libcrypto.a(fips.o): in function `verify_checksums':
(.text+0x524): undefined reference to `dlopen'
/usr/bin/ld: (.text+0x53f): undefined reference to `dlsym'
/usr/bin/ld: (.text+0x553): undefined reference to `dladdr'
/usr/bin/ld: (.text+0x562): undefined reference to `dlclose'
/usr/bin/ld: (.text+0x5b2): undefined reference to `dlclose'
/usr/bin/ld: (.text+0x62c): undefined reference to `dlclose'

</code></pre>

<p>dlopen等はライブラリを実行時に読み込む仕組み。
リンカーオプションに<code>-ldl</code>をつける。これは動的リンクにしないといけない。静的リンクしようとすると、以下のようになりうまくいかない。</p>

<pre><code>
/usr/bin/ld: /usr/lib/gcc/x86_64-redhat-linux/8/../../../../lib64/libcrypto.a(fips.o): in function `verify_checksums':
(.text+0x524): warning: Using 'dlopen' in statically linked applications requires at runtime the shared libraries from the glibc version used for linking
/usr/bin/ld: /usr/lib/gcc/x86_64-redhat-linux/8/../../../../lib64/libdl.a(dlopen.o): in function `dlopen':
(.text+0x9): undefined reference to `__dlopen'
/usr/bin/ld: /usr/lib/gcc/x86_64-redhat-linux/8/../../../../lib64/libdl.a(dlclose.o): in function `dlclose':
(.text+0x5): undefined reference to `__dlclose'
/usr/bin/ld: /usr/lib/gcc/x86_64-redhat-linux/8/../../../../lib64/libdl.a(dlsym.o): in function `dlsym':
(.text+0x9): undefined reference to `__dlsym'
/usr/bin/ld: /usr/lib/gcc/x86_64-redhat-linux/8/../../../../lib64/libdl.a(dlerror.o): in function `dlerror':
(.text+0x5): undefined reference to `__dlerror'
/usr/bin/ld: /usr/lib/gcc/x86_64-redhat-linux/8/../../../../lib64/libdl.a(dladdr.o): in function `dladdr':
(.text+0x5): undefined reference to `__dladdr'
</code></pre>

<p><code>libdl.a</code>ではdlopenなどは定義されているが、内部で使われている<code>__dlopen</code>などはglibcに依存している。
なので、glibcをstatic linkするか、同バージョンのglibcライブラリを合わせて持ち込む必要がある。</p>

<p>ここらでglibcがLGPLと知ったり、NSS周りの扱いを知ったり、muslの置き換えがうまくいかなかったり、等々を理由に「めんどくさそう」と判断して、一部static linkを目指すことにした。</p>
]]></content>
		</item>
		
		<item>
			<title>Using HUGO</title>
			<link>https://fukasawah.github.io/posts/using-hugo/</link>
			<pubDate>Mon, 24 Dec 2018 04:48:16 +0900</pubDate>
			
			<guid>https://fukasawah.github.io/posts/using-hugo/</guid>
			<description>HUGO HUGO - https://gohugo.io/ 静的サイトジェネレータ。Markdownを書けばHTMLを作ってくれる。 また、記事の公開には、Github Pagesを使う。Netl</description>
			<content type="html"><![CDATA[

<h2 id="hugo">HUGO</h2>

<p>HUGO - <a href="https://gohugo.io/">https://gohugo.io/</a></p>

<p>静的サイトジェネレータ。Markdownを書けばHTMLを作ってくれる。</p>

<p>また、記事の公開には、<a href="https://pages.github.com/">Github Pages</a>を使う。Netlifyも試したいが、こちらの方が手軽そうだったので。</p>

<p>導入のモチベーションとしては、簡単なBlogがほしい、広告嫌、という場合に、これならいい感じに公開できるかも、と思い使い始めた。</p>

<h2 id="導入">導入</h2>

<h3 id="hugoのダウンロード">HUGOのダウンロード</h3>

<p>Windowsの場合、<a href="https://discourse.gohugo.io/t/error-failed-to-create-file-caches-from-configuration-file-exists/15635/18">0.52でcachedir周りのバグがあるらしく使えない模様</a>
そのため、0.51を使用した。</p>

<p>1個のバイナリファイルになっているのでそのまま扱う。
PATHは適当に通す。</p>

<h3 id="サイトを作る">サイトを作る</h3>

<pre><code>hugo new site blog
</code></pre>

<p>以降は作成したサイトのディレクトリで作業をする</p>

<pre><code>cd blog
</code></pre>

<h3 id="gitで管理を始める">Gitで管理を始める</h3>

<p>作ったサイトごとにGitリポジトリを作る。</p>

<pre><code>git init
</code></pre>

<h3 id="テーマを決める">テーマを決める</h3>

<p>1から作るのは手間なので、 <a href="https://themes.gohugo.io/">https://themes.gohugo.io/</a> を見ていい感じのを探す。今回は<a href="https://themes.gohugo.io/hermit/">hermit</a>にした。</p>

<pre><code>git submodule add -b v1.1.0 https://github.com/Track3/hermit.git themes/hermit
echo 'theme = &quot;hermit&quot;' &gt;&gt; config.toml
</code></pre>

<p>hermitはいくつか設定が必要なので、追記する。
<a href="https://github.com/Track3/hermit/blob/master/exampleSite/config.toml">hermitのサンプルのconfig.toml</a>を参考に以下のようにした。</p>

<p><code>dateform*</code>辺りは必須。<code>/posts/</code>のmenuもあったほうがよい。</p>

<pre><code>cat &lt;&lt; '__EOF__' &gt;&gt; config.toml
[Params]
  dateform        = &quot;Jan 2, 2006&quot;
  dateformShort   = &quot;Jan 2&quot;
  dateformNum     = &quot;2006-01-02&quot;
  dateformNumTime = &quot;2006-01-02 15:04 -0700&quot;

  homeSubtitle = &quot;I feel like to be lazy&quot;

  justifyContent = false

[menu]
  [[menu.main]]
    name = &quot;Posts&quot;
    url = &quot;/posts/&quot;
    weight = 10

__EOF__
</code></pre>

<p>テーマは色々設定がある場合があるため、テーマを使う場合はこの辺りを注意する（dateform当たりの設定がないせいで後述のローカル起動で失敗して困っていた）</p>

<p>下地はここまで。</p>

<h2 id="github-pages用のリポジトリを作る">GitHub Pages用のリポジトリを作る</h2>

<p>*.github.ioというリポジトリを作っておくと、<a href="https://pages.github.com/">Github Pages</a>で見ることができるようになる。</p>

<p>このリポジトリにHTMLなどで作られたファイルを管理するだけで、Github Pagesの機能でホスティングされ、インターネット上に公開される。</p>

<p>今回はHUGOで出来た成果物を、このGitHub Pagesで公開するようにする。</p>

<h3 id="リポジトリを作成する">リポジトリを作成する</h3>

<p><code>ユーザ名.github.io</code>という形を取る必要がある。fukasawahというidなら<code>fukasawah.github.io</code>という感じ。</p>

<p>1個はcommitが無いとsubmodule登録できないので、index.html辺りを作っておく。</p>

<p>README.md でもよいが、その場合は後で削除する必要がある。github.ioはREADME.md &gt; index.htmlの順でトップを表示するため。</p>

<p>README.mdかindex.htmlが作成できたら、<code>https://ユーザ名.github.io</code>という形でアクセスできるか一度ブラウザで確認する。</p>

<p>反映までタイムラグがあるので、1分ほど待って確認する。</p>

<h3 id="リポジトリをサブモジュールとして登録する">リポジトリをサブモジュールとして登録する</h3>

<pre><code>git submodule add https://github.com/fukasawah/ユーザ名.github.io.git public
</code></pre>

<h3 id="config-tomlのbaseurlを修正する">config.tomlのbaseURLを修正する</h3>

<p>テーマによってはこの変数を元に作る場合があるので、直す。</p>

<pre><code>baseURL = &quot;https://ユーザ名.github.io/&quot;
</code></pre>

<h2 id="記事を作成">記事を作成</h2>

<h3 id="記事を作成-1">記事を作成</h3>

<pre><code>hugo new posts/using-hugo.md
</code></pre>

<p><code>content/posts/using-hugo.md</code> が出来上がるので、MarkDowkで書いていく。</p>

<pre><code>---
title: &quot;Using HUGO&quot;
date: 2018-12-24T04:48:16+09:00
draft: false
featuredImg: &quot;&quot;
tags:
  - HUGO
---

HUGO
--------------

HUGO - https://gohugo.io/

サイトジェネレータ。Markdownを書けばHTMLを作ってくれる。

</code></pre>

<p>というかんじで。最初の数行はメタ情報でなんとなく何を意味するかわかるはず。</p>

<ul>
<li><code>draft</code>がtrueの場合、デフォルトだと対象にならない(HTMLが生成されない)なので、適宜手でfalseにする必要がありそう。</li>
</ul>

<h3 id="表示確認">表示確認</h3>

<p><code>hugo server</code>により、手元で簡単に表示の確認を行える。</p>

<p><code>http://localhost:1313/</code> にアクセスすると見れる。</p>

<p><code>draft:true</code>の記事も含めたい場合は、<code>hugo server -D</code>という形に<code>-D</code>オプションを付け足す。</p>

<p>なお、デフォルトで保存を検知してブラウザ側で自動リロードをかけてくれる。</p>

<h3 id="ビルドを行う">ビルドを行う</h3>

<pre><code>hugo
</code></pre>

<p><code>public</code>ディレクトリの下に生成されたファイルが並ぶ。</p>

<h3 id="ビルドを行い-github-ioのリモートリポジトリに反映する">ビルドを行い、github.ioのリモートリポジトリに反映する</h3>

<p><code>hugo</code>を実行すると、draftになっていないものを対象に、<code>public</code>ディレクトリの下にファイルが生成される。</p>

<p>後は生成されたpublicの中身をcommit&amp;pushする。
submoduleとはいえ、中身はGitリポジトリなので、普通にGitの操作でよい。</p>

<pre><code>(
  hugo &amp;&amp; \
  cd public &amp;&amp; \
  git add . &amp;&amp; \
  git commit -m &quot;Update&quot; &amp;&amp; \
  git push
)
</code></pre>

<p>反映までタイムラグがあるので、その時は少し待って確認する。</p>

<p>良く使うはずなので、<code>.bash_profile</code>等にaliasを作っておくと良い。</p>

<pre><code>alias hugo-publish='(hugo &amp;&amp; cd public &amp;&amp; git add . &amp;&amp; git commit -m &quot;Update&quot; &amp;&amp; git push)'
</code></pre>

<h3 id="元の記事もローカルリポジトリにコミットする">元の記事もローカルリポジトリにコミットする</h3>

<p>元のMarkdownや設定が管理されていないので、このタイミングで管理する。publicも含めてしまってよい。</p>

<pre><code>git add .
git commit -m &quot;Update&quot;
</code></pre>

<p>（不明点: resources配下に生成されたファイルも含まれてしまうがこれは良いのか？）</p>

<p>後は、必要に応じてリモートリポジトリを作りPushしておくと、他の端末からでもHUGOがあれば同じ環境を使うことができるようになる。</p>

<h3 id="おわり">おわり</h3>

<p>これでHUGO+GitHub Pagesで簡単なBlogを書くことができるようになった。</p>

<p>今回の成果物は以下。</p>

<ul>
<li>HUGO以外の完全なコード: <a href="https://github.com/fukasawah/blog">https://github.com/fukasawah/blog</a></li>
<li>GitHub Pages用リポジトリ: <a href="https://github.com/fukasawah/fukasawah.github.io">https://github.com/fukasawah/fukasawah.github.io</a></li>
<li>GitHub Pages: <a href="https://fukasawah.github.io">https://fukasawah.github.io</a></li>
</ul>

<h2 id="おまけ">おまけ</h2>

<h3 id="投稿に画像の貼り付けを行いたい">投稿に画像の貼り付けを行いたい</h3>

<p>hugoはデフォルトで<code>static</code>配下のディレクトリとファイルを、そのまま<code>public</code>に配置する模様。</p>

<p>なので、<code>static/foo/image.jpg</code>とおいておけば、<code>![](/foo/image.jpg)</code>で表示ができるようになる。</p>

<p>また、VSCode で <a href="https://marketplace.visualstudio.com/items?itemName=mushan.vscode-paste-image">Paste Imageという拡張機能</a>を使っている場合、以下の設定を行っておくと、ファイルは<code>static/images/Postのファイル名/タイムスタンプ.png</code>、Markdownには<code>![](/images/ファイル名/タイムスタンプ.png)</code>が張り付けられるようになり、良い感じになる。（絶対パスになっているので、URLの構造に注意）</p>

<p>設定はWorkspace毎に設定できるので、hugoを使っている環境にだけ適用したい、という事もできる。（ディレクトリのルートの<code>.vscode/settings.json</code>に書くだけ）</p>

<pre><code>{
    &quot;pasteImage.path&quot;: &quot;${projectRoot}/static/images/${currentFileNameWithoutExt}&quot;,
    &quot;pasteImage.insertPattern&quot;: &quot;${imageSyntaxPrefix}/images/${currentFileNameWithoutExt}/${imageFileName}${imageSyntaxSuffix}&quot;
}
</code></pre>

<p>以下は画像。貼り付けのお試し。</p>

<p><img src="/images/using-hugo/2018-12-25-16-45-13.png" alt="" /></p>
]]></content>
		</item>
		
	</channel>
</rss>
