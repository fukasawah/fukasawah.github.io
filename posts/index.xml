<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on fukasawah&#39;s blog</title>
		<link>https://fukasawah.github.io/posts/</link>
		<description>Recent content in Posts on fukasawah&#39;s blog</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>ja-JP</language>
		<lastBuildDate>Mon, 07 Jan 2019 03:15:17 +0900</lastBuildDate>
		<atom:link href="https://fukasawah.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>GNU ldで一部をスタティックリンクにする</title>
			<link>https://fukasawah.github.io/posts/a-part-static-link-in-gnu-ld/</link>
			<pubDate>Mon, 07 Jan 2019 03:15:17 +0900</pubDate>
			
			<guid>https://fukasawah.github.io/posts/a-part-static-link-in-gnu-ld/</guid>
			<description>tl;dr gccなら-Wl,...でリンク時のオプション(==ldコマンドのオプション)を渡せる。オプションが複数ある場合はカンマで繋げる。 ldのオ</description>
			<content type="html"><![CDATA[

<h2 id="tl-dr">tl;dr</h2>

<p><code>gcc</code>なら<code>-Wl,...</code>でリンク時のオプション(==<code>ld</code>コマンドのオプション)を渡せる。オプションが複数ある場合はカンマで繋げる。</p>

<p><code>ld</code>のオプションで動的(<code>-Bdynamic</code>)と静的(<code>-Bstatic</code>)を選ぶことができ、これは混在させることができる。</p>

<p>例: glibc以外をstatic linkしたい</p>

<pre><code>g++ -o a.out main.o -static-libgcc -static-libstdc++ -Wl,-Bdynamic,-lc,-ldl,-lpthread,-Bstatic,-lboost_program_options,-lboost_filesystem,-lboost_system,-lssl,-lcrypto,-lz
</code></pre>

<p><code>-lc,-ldl,-lpthread</code>あたりがglibcのライブラリ。</p>

<h2 id="背景">背景</h2>

<p>時代はコンテナや！シングルバイナリのほうが扱い楽やで！！「実行する環境によっては～」なんて考える必要なくなるで！！</p>

<p>という雑な認識で、static linkしていくぞという感じです。詳細は伏せますが、C++でBoost等を扱ってるネットワークアプリケーションです。</p>

<p>最初は軽くググって<code>-static</code>とか<code>-static-libgcc -static-libstdc++</code>辺りをつけておけばそうなるんでしょ？と思っていて、以下のようにやっていた。</p>

<pre><code># g++ -o a.out main.o -lboost_program_options -lboost_filesystem -lboost_system -lpthread -lssl -lcrypto -lz -ldl -static -static-libstdc

...中略
warning: Using 'getaddrinfo' in statically linked applications requires at runtime the shared libraries from the glibc version used for linking
warning: Using 'gethostbyname' in statically linked applications requires at runtime the shared libraries from the glibc version used for linking
...中略

# ldd a.out
        not a dynamic executable
</code></pre>

<p>警告が出ながらも実行ファイルが出来てしまう。私は愚かなので「これでうまく動くぞ！」と思った。
しかし、いざコンテナにコピーして実行してみると、通信時に名前解決が出来ずハマった。具体的には、docker-composeで実行した時にコンテナの名前解決ができなかった。
名前解決できていないようなので「/etc/resolve.confかなぁ？」とか「でも中に入ってcurlは実行できたから違いそうだし・・・」とか1日中悩んでた。警告嫁。</p>

<p>原因はglibcのNSS回りだった。</p>

<h3 id="glibcのnssの壁">glibcのNSSの壁</h3>

<p>glibcをstatic linkすると、Name Service Switch(NSS)の都合で名前解決に支障が出るバイナリになる。</p>

<p>調べてみると、<a href="https://sourceware.org/glibc/wiki/FAQ#Even_statically_linked_programs_need_some_shared_libraries_which_is_not_acceptable_for_me.__What_can_I_do.3F">glibcはNSSの都合上、static linkは推奨していないようだ。</a>
（glibcはNSSはリンク時ではなく実行時に解決できるほうが良いとしている。ただ、これでstatic linkは事実上出来ないようなものなので、static linkしようとしたら警告じゃなくてエラーにしてほしい・・・）</p>

<p>NSSをstatic linkで扱う機能はオプショナルで、Fedoraのyumで入れられるglibcパッケージは対応していない。</p>

<p>なので、取れる手は以下の3つらしい。</p>

<ol>
<li>glibcを動的リンクして使う（従来通り）</li>
<li>glibcを<code>--enable-static-nss</code>をつけてrebuildし、必要なサービスを静的リンクする</li>
<li>glibcを辞めてlibc互換ライブラリに置き換える（musl等）</li>
</ol>

<p>今回は(1)の方法を取った。</p>

<p>でも、それだけなら<code>-ldl -static -static-libstdc</code>を外して動的リンクすればよい。</p>

<p>これでは何も新しい事をしていない。なので、glibc以外をstatic linkにしようと考えた。</p>

<p>本来の目的のシングルバイナリ化をするなら(2)と(3)なので、そのうち試したい所&hellip;</p>

<h3 id="リンカーとは">リンカーとは</h3>

<p>ふわっと理解しているつもりで説明すると、C言語、C++ではコンパイル→リンクという流れで成果物（実行ファイル・ライブラリ等）が出来上がる。</p>

<p>例えば「ライブラリの関数を呼ぼうとしたときに、その関数がどこにあるのか？」というのを、コンパイル後に行っている「リンク」のタイミングで解決している。
具体例で言えば、printfはおまじない的に<code>#include &lt;stdio.h&gt;</code>と書いていると使えるが、じゃあ実際にprintfに該当する処理はどこにあるんだ？というのを「リンク」のタイミングで解決する。</p>

<p>「リンク」の作業を行うのが「リンカー」でリンクのやり方は大きく分けてDynamic LinkとStatic Linkがある。</p>

<p>Dynamic Linkなら、ライブラリが実在すればそれでよしとして、成果物に含まれている「実行時に読み込むライブラリ一覧」みたいなものにライブラリ名を記録しておき、実行時に読みに行くような形を取る。成果物には実行時に読むという処理は含まれておらず、<code>ld.so</code>等の「プログラム実行時にライブラリを探すプログラム（動的リンカー）」の力を借りる必要がある。（ちなみにどの動的リンカーを使うかは成果物に含まれている情報から読み取る）</p>

<p>Static Linkなら、ライブラリが持つ実際の処理(関数等)を探して成果物に含める。</p>

<p>実際はもっと複雑な事をやってると思いますが、多分あってるんじゃないかな・・・</p>

<h3 id="リンカーのオプション">リンカーのオプション</h3>

<p><code>gcc</code>はコンパイルのあと、必要であればリンクも（<code>ld</code>コマンドを呼び出して）行う。
この時に<code>ld</code>コマンドのオプションを<code>-Wl,[OPTION],[OPTION],...</code>という感じに渡せる。オプションが複数ある場合はカンマ(<code>,</code>)で繋げる。</p>

<p><code>ld</code>のオプションで動的(<code>-Bdynamic</code>)と静的(<code>-Bstatic</code>)を選ぶことができ、混在させることができる。</p>

<p><code>ld</code>の実行内容が気になる場合、<code>-v,--verbose</code>辺りをつけると少し見えます。どうやってライブラリを探しているのか等が気になる場合につける。</p>

<p>例: glibc以外をstatic linkしたい</p>

<pre><code>g++ -o a.out main.o -static-libgcc -static-libstdc++ -Wl,-Bdynamic,-lc,-ldl,-lpthread,-Bstatic,-lboost_program_options,-lboost_filesystem,-lboost_system,-lssl,-lcrypto,-lz
</code></pre>

<p><code>-lc,-ldl,-lpthread</code>辺りはglibcに含まれるライブラリでべったり依存しているので、ここら辺は動的リンクにします。</p>

<h3 id="成果">成果</h3>

<p>通常時</p>

<pre><code># g++ -o a.out main.o -Wl,-lpthread,-lboost_program_options,-lboost_filesystem,-lboost_system,-lssl,-lcrypto,-lz
# ldd a.out | sort
        /lib64/ld-linux-x86-64.so.2 (0x00007f9f7d619000)
        libboost_filesystem.so.1.66.0 =&gt; /lib64/libboost_filesystem.so.1.66.0 (0x00007f9f7d54d000)
        libboost_program_options.so.1.66.0 =&gt; /lib64/libboost_program_options.so.1.66.0 (0x00007f9f7d56a000)
        libboost_system.so.1.66.0 =&gt; /lib64/libboost_system.so.1.66.0 (0x00007f9f7d546000)
        libcrypto.so.1.1 =&gt; /lib64/libcrypto.so.1.1 (0x00007f9f7d1d6000)
        libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f9f7ccbd000)
        libdl.so.2 =&gt; /lib64/libdl.so.2 (0x00007f9f7ccab000)
        libgcc_s.so.1 =&gt; /lib64/libgcc_s.so.1 (0x00007f9f7ce83000)
        libm.so.6 =&gt; /lib64/libm.so.6 (0x00007f9f7ce9e000)
        libpthread.so.0 =&gt; /lib64/libpthread.so.0 (0x00007f9f7d5ed000)
        librt.so.1 =&gt; /lib64/librt.so.1 (0x00007f9f7ccb3000)
        libssl.so.1.1 =&gt; /lib64/libssl.so.1.1 (0x00007f9f7d4b0000)
        libstdc++.so.6 =&gt; /lib64/libstdc++.so.6 (0x00007f9f7d022000)
        libz.so.1 =&gt; /lib64/libz.so.1 (0x00007f9f7d1ba000)
        linux-vdso.so.1 (0x00007ffdf87b5000)
</code></pre>

<p>一部を静的リンク</p>

<pre><code># g++ -o a.out main.o -static-libgcc -static-libstdc++ -Wl,-Bdynamic,-lc,-ldl,-lpthread,-Bstatic,-lboost_program_options,-lboost_filesystem,-lboost_system,-lssl,-lcrypto,-lz
# ldd a.out | sort
        /lib64/ld-linux-x86-64.so.2 (0x00007fa5d1ed4000)
        libc.so.6 =&gt; /lib64/libc.so.6 (0x00007fa5d1d04000)
        libdl.so.2 =&gt; /lib64/libdl.so.2 (0x00007fa5d1cfe000)
        libm.so.6 =&gt; /lib64/libm.so.6 (0x00007fa5d1b58000)
        libpthread.so.0 =&gt; /lib64/libpthread.so.0 (0x00007fa5d1cdc000)
        linux-vdso.so.1 (0x00007ffcf53cd000)
</code></pre>

<p>boost等が消えて、4つのライブラリにしか依存していないように見える。良いですね。</p>

<h3 id="おまけ-nssを考慮する">（おまけ）NSSを考慮する</h3>

<p>が、glibcのNSSの都合で、一部はリンク時ではなく実行時に解決される。実行時のものはlddでも表示されない。</p>

<p>ソースコードを<a href="https://sourceware.org/git/?p=glibc.git;a=blob;f=nss/nsswitch.c;h=ee46f24424bc1ca2085f4fd7f1060ae330ee5bae;hb=437faa9675dd916ac7b239d4584b932a11fbb984#l363"><code>nss/nsswitch.c</code>のこの辺り</a>で<code>/etc/nsswitch.conf</code>に書かれたサービス名(dns等)を使って、ライブラリ名を構築して、ライブラリを読みに行こうとしているのがわかる。</p>

<p>なので、もし、<code>/etc/nsswitch.conf</code>の内容が以下の場合、</p>

<pre><code>hosts: files dns
</code></pre>

<p>さらに以下を加える必要がある。</p>

<ul>
<li>/lib64/libnss_files-2.28.so</li>
<li>/lib64/libnss_dns-2.28.so</li>
<li>/lib64/libresolv-2.28.so (dnsの依存)</li>
</ul>

<p>もちろん、libresolvといった依存ライブラリがあるモノは一緒に含めないといけない。
あと、ファイルパスは実行環境やglibcのバージョンなどで変わるはずなので、<code>ldd /lib64/libnss_dns-2.28.so</code>等で、いい感じに見極めてください。</p>

<p>依存ライブラリも洗い出せたのでコンテナに持ち込むぞー！となったが、これもまた苦労した。</p>

<h3 id="おまけ-コンテナを作る">（おまけ）コンテナを作る</h3>

<p>単純にライブラリをコピーしてお終いというわけにはいかなかった。</p>

<p>持ち込み先のコンテナに動的リンカーがない。そんな事があるのか？と思ったらコンテナ界隈では良く知られているらしい。</p>

<p>busyboxはそもそも<code>ld.so</code>が無い。(これは動的リンクが必要なプログラムは実行できない・・・ということ？)</p>

<p>alpineはmuslベースなので<code>ld-musl-x86_64.so.1</code>で<code>ld-linux-x86-64.so.2</code>が無い。</p>

<p>alpineで<code>apk add libc6-compat</code> すればよい、という記事をいくつか見かけて試したが、
これはただ<code>ld-musl-x86_64.so.1</code>へのシンボリックリンクを作るだけであり、私の環境では実行時に以下のようなエラーになってしまう。</p>

<pre><code>/ # /path/to/a.out
Error relocating /path/to/a.out: __fprintf_chk: symbol not found
Error relocating /path/to/a.out: makecontext: symbol not found
Error relocating /path/to/a.out: setcontext: symbol not found
Error relocating /path/to/a.out: __register_atfork: symbol not found
Error relocating /path/to/a.out: __memcpy_chk: symbol not found
Error relocating /path/to/a.out: __strcat_chk: symbol not found
Error relocating /path/to/a.out: secure_getenv: symbol not found
Error relocating /path/to/a.out: __vfprintf_chk: symbol not found
Error relocating /path/to/a.out: __memset_chk: symbol not found
Error relocating /path/to/a.out: getcontext: symbol not found
Error relocating /path/to/a.out: __sprintf_chk: symbol not found
</code></pre>

<p><code>__memset_chk</code>辺りはglibc固有の実装なので、そんなものは当然muslにはない。</p>

<p><a href="https://hub.docker.com/r/frolvlad/alpine-glibc/">alpine-glibc</a>というイメージを使う手もあるが、オフィシャルではないので使用は避けたい。</p>

<p>色々悩んだけど、そもそもビルド環境からコピーすれば良いよね、という考えに至った。</p>

<p>ということで、dockerfileはこんな感じ。</p>

<pre><code class="language-dockerfile">FROM mydev:latest as build

# ... プログラムのビルドを行う

FROM busybox
# nsswitch.confを作る(glibcがこれを読みに来る)
RUN echo 'hosts: files dns' &gt;&gt; /etc/nsswitch.conf

# ld-linux-x86-64.so.2とプログラムの依存ライブラリ
COPY --from=build /lib64/ld-linux-x86-64.so.2 /lib64/libc.so.6 /lib64/libdl.so.2 /lib64/libm.so.6 /lib64/libpthread.so.0 /lib64

# glibcが/etc/nsswitch.confを参照して利用する依存ライブラリ
COPY --from=build /lib64/libresolv-2.28.so /lib64/lib/libresolv.so.2
COPY --from=build /lib64/libnss_dns-2.28.so /lib64/libnss_dns.so.2
COPY --from=build /lib64/libnss_files-2.28.so /lib64/libnss_files.so.2

# プログラム
COPY --from=build /usr/local/src/a.out /usr/local/bin/a.out

CMD [&quot;/usr/local/bin/a.out&quot;]
</code></pre>

<p>蛇足だが、プログラム内部で<code>ld.so</code>の場所を持っているので、コマンドを実行するとちゃんと<code>ld.so</code>を使って動的リンクを行ってくれる。(lddで<code>/lib64/ld-linux-x86-64.so.2</code>と出るなら、これを動的リンカーに使おうとする。この場所に動的リンカーが無い場合はエラーになる)
また、今回のように目的の場所に無い場合は、直接<code>ld.so</code>からプログラムを実行することもできます。もし<code>/lib64</code>ではなく、<code>/usr/local/lib</code>に全部配置した場合はこんな感じ。</p>

<pre><code>CMD [&quot;/usr/local/lib/ld-linux-x86-64.so.2&quot;, &quot;--inhibit-cache&quot;, &quot;--library-path&quot;, &quot;/usr/local/lib&quot;, &quot;/usr/local/bin/a.out&quot;]
</code></pre>

<h3 id="一部とか中途半端">一部とか中途半端</h3>

<p>はい・・・</p>

<p><code>--enable-static-nss</code>を入れたglibcでstatic linkしたりmuslの置き換えもやってみたい・・・特にmuslはlibstdc++のリビルドが必要そうなのでしんどそう。</p>

<p>glibcはLGPLなので、Static Linkすると都合悪い場合もあるはずなので、使えるのではないかなと思う。</p>

<h2 id="static化で遭遇したエラーたち">static化で遭遇したエラーたち</h2>

<h3 id="cannot-find-lgcc-s"><code>cannot find -lgcc_s</code></h3>

<pre><code>/usr/bin/ld: cannot find -lgcc_s
/usr/bin/ld: cannot find -lgcc_s
</code></pre>

<p>g++オプションに<code>-static-libgcc</code>をつける。</p>

<h3 id="undefined-reference-to-symbol-tls-get-addr-glibc-2-3"><code>undefined reference to symbol '__tls_get_addr@@GLIBC_2.3'</code></h3>

<pre><code>/usr/bin/ld: /usr/lib/gcc/x86_64-redhat-linux/8/libstdc++.a(eh_globals.o): undefined reference to symbol '__tls_get_addr@@GLIBC_2.3'
/usr/bin/ld: //lib64/ld-linux-x86-64.so.2: error adding symbols: DSO missing from command line
collect2: error: ld returned 1 exit status
</code></pre>

<p>g++オプションに<code>-static-libstdc++</code>をつける。</p>

<h3 id="undefined-reference-to-dlopen"><code>undefined reference to 'dlopen'</code></h3>

<pre><code>/usr/bin/ld: /usr/lib/gcc/x86_64-redhat-linux/8/../../../../lib64/libcrypto.a(fips.o): in function `verify_checksums':
(.text+0x524): undefined reference to `dlopen'
/usr/bin/ld: (.text+0x53f): undefined reference to `dlsym'
/usr/bin/ld: (.text+0x553): undefined reference to `dladdr'
/usr/bin/ld: (.text+0x562): undefined reference to `dlclose'
/usr/bin/ld: (.text+0x5b2): undefined reference to `dlclose'
/usr/bin/ld: (.text+0x62c): undefined reference to `dlclose'

</code></pre>

<p>dlopen等はライブラリを実行時に読み込む仕組み。
リンカーオプションに<code>-ldl</code>をつける。これは動的リンクにしないといけない。静的リンクしようとすると、以下のようになりうまくいかない。</p>

<pre><code>
/usr/bin/ld: /usr/lib/gcc/x86_64-redhat-linux/8/../../../../lib64/libcrypto.a(fips.o): in function `verify_checksums':
(.text+0x524): warning: Using 'dlopen' in statically linked applications requires at runtime the shared libraries from the glibc version used for linking
/usr/bin/ld: /usr/lib/gcc/x86_64-redhat-linux/8/../../../../lib64/libdl.a(dlopen.o): in function `dlopen':
(.text+0x9): undefined reference to `__dlopen'
/usr/bin/ld: /usr/lib/gcc/x86_64-redhat-linux/8/../../../../lib64/libdl.a(dlclose.o): in function `dlclose':
(.text+0x5): undefined reference to `__dlclose'
/usr/bin/ld: /usr/lib/gcc/x86_64-redhat-linux/8/../../../../lib64/libdl.a(dlsym.o): in function `dlsym':
(.text+0x9): undefined reference to `__dlsym'
/usr/bin/ld: /usr/lib/gcc/x86_64-redhat-linux/8/../../../../lib64/libdl.a(dlerror.o): in function `dlerror':
(.text+0x5): undefined reference to `__dlerror'
/usr/bin/ld: /usr/lib/gcc/x86_64-redhat-linux/8/../../../../lib64/libdl.a(dladdr.o): in function `dladdr':
(.text+0x5): undefined reference to `__dladdr'
</code></pre>

<p><code>libdl.a</code>ではdlopenなどは定義されているが、内部で使われている<code>__dlopen</code>などはglibcに依存している。
なので、glibcをstatic linkするか、同バージョンのglibcライブラリを合わせて持ち込む必要がある。</p>

<p>ここらでglibcがLGPLと知ったり、NSS周りの扱いを知ったり、muslの置き換えがうまくいかなかったり、等々を理由に「めんどくさそう」と判断して、一部static linkを目指すことにした。</p>
]]></content>
		</item>
		
		<item>
			<title>Using HUGO</title>
			<link>https://fukasawah.github.io/posts/using-hugo/</link>
			<pubDate>Mon, 24 Dec 2018 04:48:16 +0900</pubDate>
			
			<guid>https://fukasawah.github.io/posts/using-hugo/</guid>
			<description>HUGO HUGO - https://gohugo.io/ 静的サイトジェネレータ。Markdownを書けばHTMLを作ってくれる。 また、記事の公開には、Github Pagesを使う。Netl</description>
			<content type="html"><![CDATA[

<h2 id="hugo">HUGO</h2>

<p>HUGO - <a href="https://gohugo.io/">https://gohugo.io/</a></p>

<p>静的サイトジェネレータ。Markdownを書けばHTMLを作ってくれる。</p>

<p>また、記事の公開には、<a href="https://pages.github.com/">Github Pages</a>を使う。Netlifyも試したいが、こちらの方が手軽そうだったので。</p>

<p>導入のモチベーションとしては、簡単なBlogがほしい、広告嫌、という場合に、これならいい感じに公開できるかも、と思い使い始めた。</p>

<h2 id="導入">導入</h2>

<h3 id="hugoのダウンロード">HUGOのダウンロード</h3>

<p>Windowsの場合、<a href="https://discourse.gohugo.io/t/error-failed-to-create-file-caches-from-configuration-file-exists/15635/18">0.52でcachedir周りのバグがあるらしく使えない模様</a>
そのため、0.51を使用した。</p>

<p>1個のバイナリファイルになっているのでそのまま扱う。
PATHは適当に通す。</p>

<h3 id="サイトを作る">サイトを作る</h3>

<pre><code>hugo new site blog
</code></pre>

<p>以降は作成したサイトのディレクトリで作業をする</p>

<pre><code>cd blog
</code></pre>

<h3 id="gitで管理を始める">Gitで管理を始める</h3>

<p>作ったサイトごとにGitリポジトリを作る。</p>

<pre><code>git init
</code></pre>

<h3 id="テーマを決める">テーマを決める</h3>

<p>1から作るのは手間なので、 <a href="https://themes.gohugo.io/">https://themes.gohugo.io/</a> を見ていい感じのを探す。今回は<a href="https://themes.gohugo.io/hermit/">hermit</a>にした。</p>

<pre><code>git submodule add -b v1.1.0 https://github.com/Track3/hermit.git themes/hermit
echo 'theme = &quot;hermit&quot;' &gt;&gt; config.toml
</code></pre>

<p>hermitはいくつか設定が必要なので、追記する。
<a href="https://github.com/Track3/hermit/blob/master/exampleSite/config.toml">hermitのサンプルのconfig.toml</a>を参考に以下のようにした。</p>

<p><code>dateform*</code>辺りは必須。<code>/posts/</code>のmenuもあったほうがよい。</p>

<pre><code>cat &lt;&lt; '__EOF__' &gt;&gt; config.toml
[Params]
  dateform        = &quot;Jan 2, 2006&quot;
  dateformShort   = &quot;Jan 2&quot;
  dateformNum     = &quot;2006-01-02&quot;
  dateformNumTime = &quot;2006-01-02 15:04 -0700&quot;

  homeSubtitle = &quot;I feel like to be lazy&quot;

  justifyContent = false

[menu]
  [[menu.main]]
    name = &quot;Posts&quot;
    url = &quot;/posts/&quot;
    weight = 10

__EOF__
</code></pre>

<p>テーマは色々設定がある場合があるため、テーマを使う場合はこの辺りを注意する（dateform当たりの設定がないせいで後述のローカル起動で失敗して困っていた）</p>

<p>下地はここまで。</p>

<h2 id="github-pages用のリポジトリを作る">GitHub Pages用のリポジトリを作る</h2>

<p>*.github.ioというリポジトリを作っておくと、<a href="https://pages.github.com/">Github Pages</a>で見ることができるようになる。</p>

<p>このリポジトリにHTMLなどで作られたファイルを管理するだけで、Github Pagesの機能でホスティングされ、インターネット上に公開される。</p>

<p>今回はHUGOで出来た成果物を、このGitHub Pagesで公開するようにする。</p>

<h3 id="リポジトリを作成する">リポジトリを作成する</h3>

<p><code>ユーザ名.github.io</code>という形を取る必要がある。fukasawahというidなら<code>fukasawah.github.io</code>という感じ。</p>

<p>1個はcommitが無いとsubmodule登録できないので、index.html辺りを作っておく。</p>

<p>README.md でもよいが、その場合は後で削除する必要がある。github.ioはREADME.md &gt; index.htmlの順でトップを表示するため。</p>

<p>README.mdかindex.htmlが作成できたら、<code>https://ユーザ名.github.io</code>という形でアクセスできるか一度ブラウザで確認する。</p>

<p>反映までタイムラグがあるので、1分ほど待って確認する。</p>

<h3 id="リポジトリをサブモジュールとして登録する">リポジトリをサブモジュールとして登録する</h3>

<pre><code>git submodule add https://github.com/fukasawah/ユーザ名.github.io.git public
</code></pre>

<h3 id="config-tomlのbaseurlを修正する">config.tomlのbaseURLを修正する</h3>

<p>テーマによってはこの変数を元に作る場合があるので、直す。</p>

<pre><code>baseURL = &quot;https://ユーザ名.github.io/&quot;
</code></pre>

<h2 id="記事を作成">記事を作成</h2>

<h3 id="記事を作成-1">記事を作成</h3>

<pre><code>hugo new posts/using-hugo.md
</code></pre>

<p><code>content/posts/using-hugo.md</code> が出来上がるので、MarkDowkで書いていく。</p>

<pre><code>---
title: &quot;Using HUGO&quot;
date: 2018-12-24T04:48:16+09:00
draft: false
featuredImg: &quot;&quot;
tags:
  - HUGO
---

HUGO
--------------

HUGO - https://gohugo.io/

サイトジェネレータ。Markdownを書けばHTMLを作ってくれる。

</code></pre>

<p>というかんじで。最初の数行はメタ情報でなんとなく何を意味するかわかるはず。</p>

<ul>
<li><code>draft</code>がtrueの場合、デフォルトだと対象にならない(HTMLが生成されない)なので、適宜手でfalseにする必要がありそう。</li>
</ul>

<h3 id="表示確認">表示確認</h3>

<p><code>hugo server</code>により、手元で簡単に表示の確認を行える。</p>

<p><code>http://localhost:1313/</code> にアクセスすると見れる。</p>

<p><code>draft:true</code>の記事も含めたい場合は、<code>hugo server -D</code>という形に<code>-D</code>オプションを付け足す。</p>

<p>なお、デフォルトで保存を検知してブラウザ側で自動リロードをかけてくれる。</p>

<h3 id="ビルドを行う">ビルドを行う</h3>

<pre><code>hugo
</code></pre>

<p><code>public</code>ディレクトリの下に生成されたファイルが並ぶ。</p>

<h3 id="ビルドを行い-github-ioのリモートリポジトリに反映する">ビルドを行い、github.ioのリモートリポジトリに反映する</h3>

<p><code>hugo</code>を実行すると、draftになっていないものを対象に、<code>public</code>ディレクトリの下にファイルが生成される。</p>

<p>後は生成されたpublicの中身をcommit&amp;pushする。
submoduleとはいえ、中身はGitリポジトリなので、普通にGitの操作でよい。</p>

<pre><code>(
  hugo &amp;&amp; \
  cd public &amp;&amp; \
  git add . &amp;&amp; \
  git commit -m &quot;Update&quot; &amp;&amp; \
  git push
)
</code></pre>

<p>反映までタイムラグがあるので、その時は少し待って確認する。</p>

<p>良く使うはずなので、<code>.bash_profile</code>等にaliasを作っておくと良い。</p>

<pre><code>alias hugo-publish='(hugo &amp;&amp; cd public &amp;&amp; git add . &amp;&amp; git commit -m &quot;Update&quot; &amp;&amp; git push)'
</code></pre>

<h3 id="元の記事もローカルリポジトリにコミットする">元の記事もローカルリポジトリにコミットする</h3>

<p>元のMarkdownや設定が管理されていないので、このタイミングで管理する。publicも含めてしまってよい。</p>

<pre><code>git add .
git commit -m &quot;Update&quot;
</code></pre>

<p>（不明点: resources配下に生成されたファイルも含まれてしまうがこれは良いのか？）</p>

<p>後は、必要に応じてリモートリポジトリを作りPushしておくと、他の端末からでもHUGOがあれば同じ環境を使うことができるようになる。</p>

<h3 id="おわり">おわり</h3>

<p>これでHUGO+GitHub Pagesで簡単なBlogを書くことができるようになった。</p>

<p>今回の成果物は以下。</p>

<ul>
<li>HUGO以外の完全なコード: <a href="https://github.com/fukasawah/blog">https://github.com/fukasawah/blog</a></li>
<li>GitHub Pages用リポジトリ: <a href="https://github.com/fukasawah/fukasawah.github.io">https://github.com/fukasawah/fukasawah.github.io</a></li>
<li>GitHub Pages: <a href="https://fukasawah.github.io">https://fukasawah.github.io</a></li>
</ul>

<h2 id="おまけ">おまけ</h2>

<h3 id="投稿に画像の貼り付けを行いたい">投稿に画像の貼り付けを行いたい</h3>

<p>hugoはデフォルトで<code>static</code>配下のディレクトリとファイルを、そのまま<code>public</code>に配置する模様。</p>

<p>なので、<code>static/foo/image.jpg</code>とおいておけば、<code>![](/foo/image.jpg)</code>で表示ができるようになる。</p>

<p>また、VSCode で <a href="https://marketplace.visualstudio.com/items?itemName=mushan.vscode-paste-image">Paste Imageという拡張機能</a>を使っている場合、以下の設定を行っておくと、ファイルは<code>static/images/Postのファイル名/タイムスタンプ.png</code>、Markdownには<code>![](/images/ファイル名/タイムスタンプ.png)</code>が張り付けられるようになり、良い感じになる。（絶対パスになっているので、URLの構造に注意）</p>

<p>設定はWorkspace毎に設定できるので、hugoを使っている環境にだけ適用したい、という事もできる。（ディレクトリのルートの<code>.vscode/settings.json</code>に書くだけ）</p>

<pre><code>{
    &quot;pasteImage.path&quot;: &quot;${projectRoot}/static/images/${currentFileNameWithoutExt}&quot;,
    &quot;pasteImage.insertPattern&quot;: &quot;${imageSyntaxPrefix}/images/${currentFileNameWithoutExt}/${imageFileName}${imageSyntaxSuffix}&quot;
}
</code></pre>

<p>以下は画像。貼り付けのお試し。</p>

<p><img src="/images/using-hugo/2018-12-25-16-45-13.png" alt="" /></p>
]]></content>
		</item>
		
	</channel>
</rss>
